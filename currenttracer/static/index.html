<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Current Tracer</title>
    <link rel="stylesheet" href="/style.css">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.125/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.125/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        .cesium-widget-credits { display: none !important; }
    </style>
</head>
<body>

<div id="globe"></div>

<div id="controls">
    <label>
        Duration (days):
        <input id="duration" type="number" value="30" min="1" max="60" style="width:60px">
    </label>
    <label>
        Max tracers:
        <input id="maxTracers" type="number" value="5" min="1" max="20" style="width:50px">
    </label>
    <label>
        Speed:
        <input id="speed" type="range" min="1" max="15" value="3" style="width:100px">
    </label>
    <button id="go" disabled style="margin-top:4px;cursor:pointer;font-weight:bold">Go!</button>
    <button id="reset" style="margin-top:4px;cursor:pointer">Reset</button>
    <div id="hint" style="font-size:12px;color:#aaa">Click the ocean to place tracers, then hit Go!</div>
</div>

<div id="status"></div>

<script>
    async function init() {
    const configResp = await fetch('/config').then(r => r.json());
    Cesium.Ion.defaultAccessToken = configResp.cesium_token;
    const maxHours = configResp.max_hours || 720; // fallback to 30 days

    const viewer = new Cesium.Viewer('globe', {
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        sceneModePicker: false,
        navigationHelpButton: false,
        animation: false,
        timeline: false,
        fullscreenButton: false,
        selectionIndicator: false,
        infoBox: false,
        baseLayer: false,
    });

    viewer.imageryLayers.addImageryProvider(
        new Cesium.UrlTemplateImageryProvider({
            url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
            subdomains: ['a', 'b', 'c', 'd'],
            credit: 'CARTO',
        })
    );

    const statusEl = document.getElementById('status');
    const durationEl = document.getElementById('duration');
    const speedEl = document.getElementById('speed');
    const goBtn = document.getElementById('go');
    const hintEl = document.getElementById('hint');
    const maxTracersEl = document.getElementById('maxTracers');

    // --- State machine: PLACING | COMPUTING | ANIMATING | DONE ---
    let state = 'PLACING';
    let globalTime = 0;

    const tracers = [];  // active tracers (with trajectory data and entities)
    const pending = [];  // placed but not yet fetched: {lon, lat, entity}

    function updateControls() {
        const placing = (state === 'PLACING');
        durationEl.disabled = !placing;
        maxTracersEl.disabled = !placing;
    }

    // --- Reset ---
    document.getElementById('reset').addEventListener('click', () => {
        globalTime = 0;
        state = 'PLACING';
        tracers.length = 0;
        pending.length = 0;
        viewer.entities.removeAll();
        statusEl.textContent = '';
        goBtn.disabled = true;
        hintEl.textContent = 'Click the ocean to place tracers, then hit Go!';
        updateControls();
    });

    // --- Click to place tracer ---
    viewer.screenSpaceEventHandler.setInputAction((click) => {
        if (state !== 'PLACING') return;

        const maxCount = parseInt(maxTracersEl.value, 10) || 5;
        if (pending.length >= maxCount) return;

        const cartesian = viewer.camera.pickEllipsoid(
            click.position, viewer.scene.globe.ellipsoid
        );
        if (!cartesian) return;

        const carto = Cesium.Cartographic.fromCartesian(cartesian);
        const lon = Cesium.Math.toDegrees(carto.longitude);
        const lat = Cesium.Math.toDegrees(carto.latitude);

        const marker = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat),
            point: { pixelSize: 8, color: Cesium.Color.YELLOW },
        });

        pending.push({ lon, lat, entity: marker });
        goBtn.disabled = false;
        statusEl.textContent = `${pending.length}/${maxCount} tracers placed`;

        if (pending.length >= maxCount) {
            hintEl.textContent = 'Max reached. Hit Go!';
        }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // --- Go! button: fetch all trajectories and start animation ---
    goBtn.addEventListener('click', async () => {
        if (state !== 'PLACING' || pending.length === 0) return;

        state = 'COMPUTING';
        goBtn.disabled = true;
        updateControls();
        statusEl.textContent = `Computing ${pending.length} trajectories...`;

        const duration = parseFloat(durationEl.value) || 30;

        try {
            const promises = pending.map(p => {
                const url = `/trace?lon=${p.lon}&lat=${p.lat}&duration_days=${duration}&dt_hours=6&t0_hours=0`;
                return fetch(url).then(r => {
                    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
                    return r.json();
                });
            });
            const results = await Promise.all(promises);

            // Remove yellow placement markers
            for (const p of pending) {
                viewer.entities.remove(p.entity);
            }

            // Build tracer objects
            for (const data of results) {
                const traj = data.trajectory;
                if (!traj || traj.length < 2) continue;

                const positions = traj.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1]));
                let visiblePositions = [positions[0]];

                const startEntity = viewer.entities.add({
                    position: positions[0],
                    point: { pixelSize: 6, color: Cesium.Color.GREY },
                });

                const trailEntity = viewer.entities.add({
                    polyline: {
                        positions: new Cesium.CallbackProperty(() => visiblePositions, false),
                        width: 3,
                        material: new Cesium.PolylineGlowMaterialProperty({
                            glowPower: 0.15,
                            color: Cesium.Color.CYAN.withAlpha(0.6),
                        }),
                        clampToGround: true,
                    },
                });

                const headEntity = viewer.entities.add({
                    position: positions[0],
                    point: { pixelSize: 10, color: Cesium.Color.CYAN },
                });

                tracers.push({
                    startTime: 0,
                    traj,
                    positions,
                    visiblePositions,
                    trailEntity,
                    headEntity,
                    startEntity,
                    finished: false,
                    setVisible(arr) { this.visiblePositions = arr; visiblePositions = arr; },
                });
            }

            pending.length = 0;
            globalTime = 0;
            state = 'ANIMATING';
            updateControls();
            requestAnimationFrame(tick);

        } catch (e) {
            statusEl.textContent = `Request failed: ${e.message}`;
            state = 'PLACING';
            goBtn.disabled = pending.length === 0;
            updateControls();
        }
    });

    // --- Animation loop ---
    function tick() {
        if (state !== 'ANIMATING') return;

        const speed = parseInt(speedEl.value, 10);
        globalTime += speed * 0.3;

        if (globalTime > maxHours) {
            globalTime = maxHours;
            state = 'DONE';
            updateControls();
        }

        let allFinished = true;

        for (const tr of tracers) {
            const elapsed = globalTime - tr.startTime;
            if (elapsed < 0) {
                allFinished = false;
                continue;
            }

            const lastTime = tr.traj[tr.traj.length - 1][2];
            const firstTime = tr.traj[0][2];

            let idx = 0;
            for (let i = 0; i < tr.traj.length; i++) {
                if (tr.traj[i][2] - firstTime <= elapsed) {
                    idx = i;
                } else {
                    break;
                }
            }

            tr.headEntity.position = tr.positions[idx];
            tr.setVisible(tr.positions.slice(0, idx + 1));

            if (idx < tr.positions.length - 1) {
                allFinished = false;
                tr.headEntity.point.color = Cesium.Color.CYAN;
            } else if (!tr.finished) {
                tr.finished = true;
                tr.headEntity.point.color = Cesium.Color.CYAN.withAlpha(0.4);
                tr.headEntity.point.pixelSize = 6;
            }
        }

        const days = (globalTime / 24).toFixed(1);
        const maxDays = (maxHours / 24).toFixed(0);
        statusEl.textContent = `Day ${days} / ${maxDays} — ${tracers.length} tracer${tracers.length !== 1 ? 's' : ''}`;

        if (allFinished && tracers.length > 0) {
            state = 'DONE';
            updateControls();
            statusEl.textContent = `Done — day ${days}. Click Reset to start over.`;
        }

        if (state === 'ANIMATING') {
            requestAnimationFrame(tick);
        }
    }

    }
    init();
</script>
</body>
</html>
